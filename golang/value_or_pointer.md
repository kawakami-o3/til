# A Value Or Pointer


[Go: Should I Use a Pointer instead of a Copy of my Struct?](https://medium.com/a-journey-with-go/go-should-i-use-a-pointer-instead-of-a-copy-of-my-struct-44b43b104963)

実体を使うかポインターか問題。
素朴に考えると、コピーが走る分遅くなりそうだけど、実際はそうではなくてGCが働く分逆にポインターの方が遅くなることもある、という話。

Go自体のガイドラインを見てみると、この点については言及されていて

https://github.com/golang/go/wiki/CodeReviewComments#receiver-type

上記のリンクは、レシーバとしてはどちらを選ぶべきかというガイドラインで、「実体の方が速いこともあるが、実体を選ぶならちゃんと計測するように（意訳）」という文言がある。
いくつか例外があるものの、基準が曖昧な部分もあり、「迷ったらポインターでよい」とされている。

以下、適当翻訳

* レシーバーが map, func, chan ならポインターは使わない。sliceであってもサイズ変更しないのであれば、ポインターは使わない。
* レシーバーに変更を加える必要があるなら、ポインターでなければならない。
* レシーバーが sync.Mutex を含むか、同期させるフィールドを持つなら、コピーを避けるためにポインターでなければならない。
* レシーバーが大きな構造体か配列なら、ポインターレシーバーの方が効率的である。どのくらい大きければ「大きい」か？実体型はメソッドが呼ばれた際にレシーバーのコピーを行います。このため、外部での変更はこのレシーバーに適用されないだろう。もし、変更が元のレシーバーに見えなければ奈良にのであれば、レシーバーはポインターでなければならない。
* レシーバーが構造体か配列かスライスで、かつ要素がミュータブルな何かへのポインターなら、ポインターレシーバーの方が好ましい。その方が読み手も理解しやすい。
* レシーバーが小さな配列か構造体で、かつミュータブルフィールドやポインターを含まず、基本型やstringのみであれば、実体レシーバーは理にかなっている。実体レシーバーの場合、メソッド呼び出しでヒープに割り当てられるかわりにスタックにコピーされ、GCコストが下がることがある。コンパイラはこの手の割当を避けようと試みるが、常に成功するとはかぎらない。実体レシーバーを使う前に、まず計測した方が良い。
* 最後に、迷ったらポインターレシーバーを使うとよい。
* 
