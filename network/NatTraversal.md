# NAT Traversal

ここでは、以下の tailscale の記事をかいつまんで NAT traversal の手法についてまとめてみる。

https://tailscale.com/blog/how-nat-traversal-works/


前提として、UDPを使ってソケットを直接操作することを念頭において説明する。

ソケット直接操作は煩雑だけれども、ローカルproxyレイヤーをおいてNAT traversalを行わせることで、
もとのプログラムを変更せずに目的を達成できるようになる。


障害となるのは、ステートフルなファイヤーウォールとNATデバイス。


## Figuring out firewalls

たとえば

* Windows Defender firewall
* Ubuntu's ufw
* BSD's pf
* AWS's Security Groups

インバウンドとアウトバウンド。
ステートフルなファイヤーウォールは、パケットの行き来するのを記録して、インバンドかアウトバンドかを決めている。
UDPであれば、インバウンドのパケットが許可されるのは、アウトバウンドに記録されていた場合。
例として、IPアドレスとポートが一致していた場合が挙げられている。
もっとゆるい例として、ファイヤーウォールの内側の端末（laptop）からパケットを送信した場合に、
そのIPアドレスとポートへのパケットならすべて許容する場合もあるらしい。


### Firewall face-off

最初にアウトバウンドの通信を行わなければならないのだが、お互いにファイヤーウォールの内側にいた場合はどちらの側からもパケットが届かない。

ファイヤーウォールの設定を変更できるならよいが、ユーザーに設定変更を求めるのは難しく、また変更できる状況にないこともある。

### Finessing finicky firewalls

「パケットは、受信する前に、送信されていないければならない」

もちろん、対象となるIPアドレスやポートに正しく紐付いていなければならない。
送信元と送信先さえ正しくパケットが送信されていれば、返信と思われるパケットは許可される、たとえ相手に届いていなかったとしても。

なので、まずはじめに相手の `ip:port` が分かっていないといけない。
手動で決定してもよいがスケールしないとのことで、Tailscale では coordination server を用意しているらしい。

そして、お互いにUDPパケットを送り合う。
この段階では、いくつかのパケットはロストするだろう。

`ip:port` の例を用いた図説あり。


### Creative connectivity caveats

注意点として、だいたい同時にパケットを送信し合う必要があることが挙げられる。
繋がるまでリトライすることもできるが、これは無駄が多い。

送信の同期を図るために別のシステムを使うこともある。

また、ファイヤーウォールはメモリが限られているので、定期的にパケットを飛ばしたり、再接続を行う必要がある。

さらに、`id:port`まわりで難点がある。以下につづく。

## The nature of NATs

NAT のやっかいな機能として、パケットを変更してしまうことが挙げられる。
NAT = Network Address Translator.

問題となるのはSource NAT, SNAT。
複数端末がひとつのIPアドレスのまとめられてしまう。

### Navigating a NATty network

適当にポートを選んで、プライベートIPと結びついた受信ポートとする。
この挙動について図説あり。

### A study in STUN




